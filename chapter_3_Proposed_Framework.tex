\chapter{Proposed Method}
\label{proposedmethod}

\section{Introduction}

As discussed in Chapter~\ref{introduction}, TNDP is inherently a many-objective optimization problem (MaOP). In this chapter, we formulate the solution evaluation model for the many-objective TNDP. Then, we propose a many-objective evolutionary algorithm (MaOEA) based framework for generating a diverse set of competitive solutions. Finally we look at the major differences of our framework from other recent works.

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[!htbp]
	\centering
	\caption{Nomenclature.} \label{tab:nomenclature}
	\begin{tabular}{ll}
		\hline
		%\multicolumn{2}{l}{Sets and fixed parameters} \\
		%\hline
		$ N_R $     & Number of required bus routes  \\
		$ R $     & Set of bus routes  \\
		$ E_r $   & Edge sequence for bus route $ r, r\in R  $  (Decision variable)\\
		$ R_{ij} $  & Set of competing routes between bus stop $i$ and $j$\\
		$ TR_{ij} $ & Set of competing transfer path between bus stop $i$ and $j$\\
		$ S $     & Set of shared edges among routes in $ R $ \\
		$ A_{tr} $  & Set of routes used by transfer path $ tr $ \\
		$ d_{ij} $  & Total passenger demand between bus stop $i$ and $j$ (passengers/hour) \\
		$ d_{ij}^r $ & Passenger demand between bus stop $i$ and $j$ riding on route $ r $ (passengers/hour) \\
		$ d_{ij}^{tr} $ & Passenger demand between bus stop $i$ and $j$ along transfer path $ tr $ (passengers/hour) \\
		$ t_e $   & In-vehicle travel time to traverse edge $ e $ (minutes) \\
		$ t_{ij}^r $ & In-vehicle travel time between bus stop $i$ and $j$ on route r (minutes) \\
		$ t_{ij}^{tr} $ & In-vehicle travel time between bus stop $i$ and $j$ on transfer path tr (minutes) \\ %(excluding transfer penalties)
		$ f_{min} $ & Minimum bus frequency \\
		$ f_r $   & Service frequency associated with route $ r, r\in R  $ (buses/hour) \\
		$ L_r $   & Maximum passenger load on route r \\
		$ w_r $   & Passenger waiting time on route r (minutes) \\
		$ T_r $   & Total round trip time for route r (minutes) \\
		$ C $     & Bus capacity \\
		$ min $     & Minimum number of bus stops for any route \\
		$ max $     & Maximum number of bus stops for any route \\
		\hline
		%\multicolumn{2}{l}{Decision variables} \\
		%\hline
		%$ E_r $   & Edge sequence for bus route $ r, r\in R  $  \\
		%\hline
	\end{tabular}%
	\label{tab:addlabel}%
\end{table}%

%In this chapter, we address the issues arising from binarization. We propose a framework that handles these issues. As discussed in the previous chapter, the main issue that arises from binarization is the class imbalance problem which is known for reduced accuracy. Recently some solutions have been used to solve the class imbalance problem like boosting, oversampling and undersampling. We incorporate a combination of boosting and oversampling in our framework to handle the class imbalance problem. Here, we first give some basic ideas about boosting and oversampling. Then we present our framework and how it can be modified for semi-supervised classification. We also look at how classifiers that do not have natural iteration can be incorporated in our framework. Finally, we end this chapter by looking at the major differences of our framework from other existing work.%Furthermore, we also apply our framework for semi-supervised classification.

\section{Proposed Evaluation Model}

In this section we specify the core elements of a solution evaluation model for many-objective TNDP. At first we construct mathematical formulation of our objective functions. We propose seven objective functions to express the expectations of passengers, bus operators and local authorities.
%We also incorporate five problem constraints into our model to support the transportation challenges of smart cities.
Then we present our adopted trip assignment model which is prerequisite for the evaluation of objective functions.

\subsection{Objective Formulation} \label{sec:problem_formulation}

A road network can be represented by an undirected graph $ G = (V, E) $, where $ V = \{0,1,\dots,n-1\} $ represents the set of bus stops and $ E $ represents the set of road segments between two bus stops. A bus route $ r $ is defined as a simple path (i.e. no loops/repeated vertices) through the graph G. A Transfer path $ tr $ is defined as a simple path that uses more than one route. Some frequently used notations are introduced in Table \ref{tab:nomenclature}.
Given a demand matrix $ D = \{d_{ij} | i,j \in V\} $ and travel time matrix $ T = \{t_{ij} | (i,j) \in E\} $, our task is to determine a set of $ N_R $ bus routes over $ G $ while minimizing seven objective functions and maintaining four problem constraints.

Due to extremely high complexity of TNDP, we make some simplifying assumptions which are common in the literature. These are listed as follows:
\begin{itemize}
	\item The given road network is connected.
	\item The given road network is symmetrical where the travel time, distance and demand between any two nodes is the same regardless of the travel direction.
	\item A bus travels back and forth along the same route, reversing its direction each time it reaches a terminal vertex.
	\item The average waiting time for passengers using a certain route is half of the route's headway.
%	\item Passengers always try to travel directly from origin to destination using one route only. If no direct path is available passengers bear at most one transfer.
%	\item Passengers always board the first available bus.
	\item In-vehicle travel time and waiting time are independent of congestion effect.
\end{itemize}

With the preceding assumptions and notations, now we formulate the objective functions of TNDP. Our objective functions reflect the conflicting interests of all the stakeholders: passengers, bus operators and local authorities from different dimensions.

From passengers' perspective, we construct three objectives:
\begin{itemize}
	\item Minimize total in-vehicle travel time of all served passengers expressed in passenger-minutes:
	\begin{equation}
	 \sum_{i,j \in V, i<j<n} \sum_{r \in R_{ij}} d_{ij}^r t_{ij}^r + \sum_{i,j \in V, i<j<n} \sum_{tr \in TR_{ij}} d_{ij}^{tr} t_{ij}^{tr}
	\end{equation}

	\item Minimize total waiting time of all served passenger expressed in passenger-minutes:
	\begin{equation}
	\sum_{i,j \in V, i<j<n} \sum_{r \in R_{ij}} d_{ij}^r w_r + \sum_{i,j \in V, i<j<n} \sum_{tr \in TR_{ij}} d_{ij}^{tr} \sum_{r \in A_{tr}} w_r \\
	\end{equation}
	\begin{align*}
	\text{where} &\\
				 &  w_r = \frac{60}{2f_r} \text{minutes}\\
				 &  f_r = \max \left(\frac{L_r}{C}, f_{min}
				 \right) \text{buses/hour}\\
	\end{align*}

	\item Minimize percentage of transfer:
	\begin{equation}
	\dfrac{\sum_{i,j \in V, i<j<n} \sum_{tr \in TR_{ij}} d_{ij}^{tr}}{\sum_{i,j \in V, i<j<n} d_{ij}}
	\end{equation}
	\end{itemize}

From the viewpoint of bus operators, we develop two objectives:
\begin{itemize}

	\item Minimize fleet size expressed in number of buses:
	\begin{equation}
	\sum_{r \in R} \frac{f_rT_r}{60}
	\end{equation}

	\item Minimize total route length expressed in minutes:
	\begin{equation}
	\sum_{r \in R}\sum_{e \in E_r} t_e
	\end{equation}
\end{itemize}

Furthermore, to represent local authorities' perspective we develop two more objectives:
\begin{itemize}
	\item Minimize percentage of unsatisfied demand:
	\begin{equation}
	1 - \dfrac{\sum_{i,j \in V, i<j<n} \sum_{tr \in TR_{ij}} d_{ij}^{tr}}{\sum_{i,j \in V, i<j<n} d_{ij}} - \dfrac{\sum_{i,j \in V, i<j<n} \sum_{r \in R_{ij}} d_{ij}^r}{\sum_{i,j \in V, i<j<n} d_{ij}}
	\end{equation}

	\item Minimize degree of route overlap:
	\begin{equation}
	\sum_{r \in R}\dfrac{\sum_{e \in (S \cap E_r)}t_e}{\sum_{e \in E_r}t_e}
	\end{equation}
\end{itemize}


To generate realistic transit network we incorporate the following problem constraints into our model:
\begin{itemize}
	\item The route set $ R $ must contain exactly $ N_R $ number of routes.
	\item The transit network induced by $ R $ must be connected.
	\item All bus stops in V must be in at least one route in R.
	\item Each route in $ R $ must be a simple path.
	\item Each route in $ R $ must contain between m1 and m2 bus stops.
\end{itemize}

However, these constraints significantly increase the complexity of our task.


\subsection{Trip Assignment Model}

We use the trip assignment model of \cite{baaj1990trust} to distribute the passenger demand among the bus routes of a candidate solution. It is needed to calculate the objective functions. Main assumptions of this model concerning passenger behavior are the following:

\begin{itemize}
	\item Passengers can arrive at the bus stop at any time randomly.

	\item Passengers always board the first available bus.

	\item Passengers do not consider a route as travel option if its associated travel time is considerably higher than the minimum possible travel time.

	\item Passengers' main interest is to minimize the number of transfers. Passengers always try to travel directly from origin to destination using one route only. If no direct path is available passengers bear at most one transfer.
\end{itemize}

If multiple competing routes exist between the same pair of bus stops, this model distribute the corresponding demand among these routes, in proportion with their service frequencies.  This is known as the \textit{frequency share rule}. Let, $ R_{ij} = \{r_1, r_2, \dots, r_m\} $ be the set of competing routes between bus stops $ i $ and $ j $. And $ f_k $ be the service frequency associated with the route $ r_k \in R_{ij} $. According to frequency share rule, the number of expected passengers that will take the route $ r_k $ equals:
\begin{equation}\label{eqn:frequency_share}
 \dfrac{f_k}{\sum_{l=1}^{m} f_l} d_{ij}
\end{equation}

\section{Proposed Evolutionary Framework}
In this section we propose the main components of our evolutionary framework which are designed to tackle many-objective TNDP. We start by introducing the data structure used to represent a candidate solution. Then we discuss our random walk based solution initialization procedure. Next we present the problem specific crossover operator and four mutation operators. Afterwards we design five mutation schemes by combining our mutation operators. Finally we outline four state-of-the-art evolutionary algorithms adapted to solve TNDP.

\subsection{Solution Representation}

A efficient representation of solution can make a MaOP easier to solve. The solution of TNDP is a transit network which is basically a set of bus routes. A bus route can be expressed as a list of bus stops. As such we represent each solution as an array of lists containing integer elements. The array size equals the number of routes in transit network. Each list can grow or shrink dynamically. A candidate solution along with the corresponding representation is shown in Figure \ref{fig:solution_representation}.

\begin{figure}[!htbp]
	\centering
	\begin{subfigure}[b]{0.39\textwidth}
		\includegraphics[width=\linewidth]{Figure/candidate_solution.png}
		\caption{A candidate solution with three routes
			}
	\end{subfigure}
	\hspace*{0.5cm} % separation between the subfigures
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\linewidth]{Figure/solution_representation.png}
		\caption{Corresponding representation
			}
	\end{subfigure}
	\caption{Solution representation.} \label{fig:solution_representation}
\end{figure}

\subsection{Random Initialization}

We generate each individual of the initial population at random, according to the constraints mentioned in Section \ref{sec:problem_formulation}.  The procedure for randomly generating a solution is shown in Algorithm \ref{alg:init_procedure}. It constructs required number of routes one by one. At first the length of each route is chosen randomly from a fixed interval. The first route is started from a randomly selected node. Subsequent routes are started from an used node to ensure connectivity of the resulting transit network. Each route is extended at the end nodes in a random walk fashion. The route extension process is designed to promote the inclusion of unused nodes. Nevertheless, the process does not ensure coverage of all nodes. A $Repair$ stage is applied at the end when necessary, to add the nodes that are absent in the generated solution. $Repair$ is also used to put back missing nodes following the application of crossover. The $Repair$ procedure is given in Algorithm \ref{alg:repair}. It picks a route randomly without replacement and tries to add missing nodes at both ends.

\begin{algorithm}[!htbp]
	\caption{Randomly generate a solution}
	\textbf{Input:}  $N_R$ (number of required routes), $n$ (number of nodes in the road network), $min$ (minimum number of nodes in a route), $max$ (maximum number of nodes in a route)\\
	\textbf{Output:} $RouteSet$ (the generated solution)
	\begin{algorithmic}[1]\label{alg:init_procedure}
		\STATE{$Success \leftarrow \FALSE$ } \COMMENT{indicates feasibility of the generated solution}
		\REPEAT
			\STATE{$Chosen \leftarrow \emptyset$} \COMMENT{set of nodes used so far in at least one route}
			\STATE{$RouteSet \leftarrow$ an array of $N_R$ empty lists} \COMMENT{generated solution}
			\FOR{$count \leftarrow 0$ to $(N_R-1)$}	\label{mainLoop}
				\STATE{$l \leftarrow$ select a random integer uniformly from $[min,max]$  }  \COMMENT{length of current route}
				\IF{$count =  1$}
				\STATE{$FirstNode \leftarrow $ select a node at random from $[0,(n-1)]$} \COMMENT{seed the first route}
				\ELSE
				\STATE{$FirstNode \leftarrow $ select a node at random from $Chosen$} \COMMENT{seed subsequent routes ensuring connectivity}
				\ENDIF
				\REPEAT
					\STATE{$Route \gets$ an empty list } \COMMENT{current route under construction}
					\STATE{$ChosenLocal \leftarrow Chosen$} \COMMENT{local backup}
					\STATE{Add $ FirstNode $ at the end of $ Route $}
					\STATE{$ChosenLocal \leftarrow ChosenLocal \cup FirstNode $}
					\STATE{$CurNode \leftarrow FirstNode$}
					\WHILE{length of $ Route <  l$ \AND $ Route $ has not been reversed more than once}
						\STATE{$Unused \gets$ set of nodes adjacent to $ CurNode $ but currently absent from $ Route $ }
						\IF{$Unused \neq  \emptyset$}
							 \STATE{$CurNode \leftarrow$ select a node at random from $ Unused $ encouraging the coverage} \COMMENT{this selection is biased to the less frequently used nodes}
							 \STATE{Add $ CurNode $ at the end of $ Route $}
							 \STATE{$ChosenLocal \gets ChosenLocal \cup CurNode$}
						\ELSE
						     \STATE{Reverse $Route$}
						     \STATE{$CurNode \leftarrow$ current end of $Route$}
						\ENDIF
					\ENDWHILE
				\UNTIL{length of $ Route $ is equal to $l$}
				\STATE{$RouteSet[count] \leftarrow Route$}
				\STATE{$Chosen \leftarrow ChosenLocal$}
			\ENDFOR
			\IF{$|Chosen| < n$}
				\STATE{$Routeset, Success \gets Repair(Routeset, Chosen, n, max)$}  \COMMENT{attempt to repair the solution and report the success}
			\ELSE
				\STATE{$Success \gets \TRUE$}
			\ENDIF
		\UNTIL{$Success = \TRUE$}
%		\RETURN{$RouteSet$}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htbp]
	\caption{$ Repair(Routeset, Chosen, n, max) $}
	\textbf{Input:} $Routeset$ (the solution to be repaired), $Chosen$ (set of nodes used in $Routeset$), $n$, $max$\\
	\textbf{Output:} $RouteSet$ (the repaired solution), $Success$ (indicate the success of repair attempt)
	\begin{algorithmic}[1]\label{alg:repair}
		\STATE{$Success \leftarrow \FALSE$ }
		\REPEAT
		\STATE{Select a route randomly without replacement from $Routeset$ }
		\IF{length of selected route $ < max $}
			\STATE{If possible add nodes absent in $Chosen$ to either end of the selected route}
			\STATE{ $Chosen \gets Chosen \, \cup $ \{recently added nodes\}}
		\ENDIF
		\UNTIL{$|Chosen| = n$ \OR ($|Chosen| < n$ \AND possibilities exhausted) }
		\IF{$|Chosen| = n$}
		\STATE{$Success \gets \TRUE$}
		\ENDIF
		\end{algorithmic}
\end{algorithm}

Unlike many researchers, we do not used any shortest path based heuristics to generate our initial population. Because such strategies are biased towards the objective function of minimizing travel time. As we are dealing with many-objective optimization we must not emphasize on a particular objective. Rather we want to generate a set of diverse solutions covering the whole objective space.

\subsection{Crossover}
We use the crossover operator described in Algorithm \ref{alg:crossover}, which preserves problem constraints. It is a modified version of the crossover operator proposed in \cite{mumford2013new}. Given two parent solutions, it constructs an offspring by randomly combining the bus routes of parents. At first it selects a route randomly from the first parent to be used as the first route of offspring. Then it selects the subsequent routes alternatively from each parent which maximize the proportion of unseen nodes to ensure coverage of all nodes. However, the selected route must contain at least one used node to ensure connectivity. For example, let's consider a route $ R_i = \{1, 7, 8, 9, 12, 14\} $ which is contained in one of the parents and is being considered for insertion into $Offspring$. If at that time $ Offspring = \{R_0\} $ where $ R_0 = \{12, 15, 0, 5, 3\} $ then the set of unseen nodes is $ R_i-R_0 = \{1, 7, 8, 9, 14\} $. Therefore the proportion of unseen nodes is $\frac{|R_i - R_0|}{ |R_i|} = \frac{5}{6}$ in this case. The crossover will choose this route if this proportion is maximum among all the candidate routes. This scenario is illustrated in Figure~\ref{fig:crossover}.

\begin{figure} [!htbp]
	\centering
	\includegraphics[width=13cm]{Figure/crossover}\\
	\caption{Operation of $Crossover$ (Algorithm~\ref{alg:crossover}).}\label{fig:crossover}
\end{figure}

After crossover has been applied it may happen that the offspring will not contain all the nodes of road network. In that case the $Repair$ procedure is applied that attempts to add the missing nodes to either ends of the routes.

\begin{algorithm}[!htbp]
	\caption{$ Crossover(Parents, C_r, n, max) $}
	\textbf{Input:} $Parents$ (an array of 2 parent solutions), $ C_r $ (crossover rate), $ n $, $ max $\\
	\textbf{Output:} $Offspring$ (an offspring solution) %, $Success$ (indicate the success of repair attempt)
	\begin{algorithmic}[1]\label{alg:crossover}
		\STATE{$p \leftarrow$ select a random real number uniformly from $[0,1] $  }
		\IF{ $ p > C_r $}
			\STATE{$Offspring \leftarrow Parents[0]$} \COMMENT{simply returns the first parent}
		\ELSE
			\STATE{ $N_R \gets $ number of routes in $Parents[0]$}
			\STATE{$Offspring \leftarrow$ an array of $N_R$ empty lists}
			\STATE{$CurParent \gets 0$}
			\STATE{$Count \gets 0$}
			\STATE{$Offspring[0] \leftarrow$ choose a route at random from $Parents[0]$}
			\STATE{$Chosen \leftarrow$ set of nodes used in $Offspring[0]$}
			\WHILE{$Count < N_R$}
				\STATE{$CurParent \gets (CurParent+1) \mod 2$} \\\COMMENT{pick routes from 2 parents alternatively}
				\STATE{$EligibleRoutes \leftarrow$ set of route indices of $Parents[CurParent]$ which have at least one node in common with $Chosen$} \COMMENT{for ensuring connectivity}
				\IF{$ |EligibleRoutes| = 0 $}
				\STATE{\textbf{continue}}
				\ENDIF
				\STATE{$SelectedRoute \leftarrow$ select the route index from $EligibleRoutes$ which has the largest proportion of nodes absent from $Chosen$} \COMMENT{if necessary break tie at random}
				\STATE{$Offspring[Count] \gets Parents[CurParent][SelectedRoute]$}
				\STATE{$Count \gets Count+1$}
				\STATE{$Chosen \leftarrow Chosen \, \cup$ \{nodes used in $Offspring[Count]$\}}
			\ENDWHILE
			\IF{$|Chosen| < n$}
			\STATE{$Offspring \gets Repair(Offspring, Chosen, n, max)$}  \COMMENT{attempt to add the missing nodes}
			\ENDIF
		\ENDIF
	\end{algorithmic}
\end{algorithm}

\subsection{Mutation}
We use four problem specific mutation operators for randomly modifying a solution. Some of these apply heuristics to encourage improvement in one or more objective values. All these mutation operators are carefully controlled to prevent violation of the problem constraints. The names of these mutation operators are $AddNodes$, $DeleteNodes$, $ShortenRoutes$ and $ReduceOverlap$.

$AddNodes$ was originally proposed in~\cite{mumford2013new}. At first it picks an integer randomly from a fixed interval as the number of nodes to be added. Afterwards it selects a route at random and tries to extend it by randomly adding nodes at both ends. Before adding any node it checks whether this addition will cause any violation of problem constraints. Figure~\ref{fig:add_nodes} shows an example operation of $AddNodes$ on a route. In this example, the route is extending by adding a new node $k$ (marked as dashed in part (a)) at the end node $i$. The resulting route is shown in part (b). The overall procedure is summarized in Algorithm~\ref{alg:add_nodes} It has the potential to reduce percentage of transfer and unsatisfied demand of a solution.

The idea of $DeleteNodes$ is also inspired from~\cite{mumford2013new}. It does the opposite action of $AddNodes$. It tries to delete nodes at random from the route ends. Before deleting any node it checks for any possible violation of constraints. Algorithm~\ref{alg:delete_nodes} shows the procedure of $DeleteNodes$. We carefully ensure that $DeleteNodes$ can delete maximum number of nodes from any route before violating any problem constraint. It can reduce route length and overlap of a solution.

We design $ShortenRoutes$ to improve in-vehicle travel time. Similar to $DeleteNodes$, it starts by picking a random integer as the number of nodes to be deleted. Then it iteratively selects a route at random without replacement. It traverses the selected route from a randomly chosen end to the other end and tries to delete nodes by applying triangular inequality heuristic based on travel time. Figure~\ref{fig:shorten_routes} shows an example operation of $ShortenRoutes$ on a route. In this figure, node $b$ is deleted by including a new edge $ac$ (marked as dashed in part (a)) in place of two edges $ab$ and $bc$. We present the procedure of $ShortenRoutes$ in Algorithm~\ref{alg:shorten_routes}. We can expect it to reduce in-vehicle travel time and route length of a solution.

To improve degree of route overlap and travel time simultaneously we design another operator named $ReduceOverlap$. It also uses triangular inequality to delete nodes from bus routes, but considers both travel time and edge usage.  Algorithm~\ref{alg:reduce_overlap} shows the procedure of $ReduceOverlap$. It is designed to reduce route overlap, in-vehicle travel time and route length of a solution.


\begin{figure} [!htbp]
	\centering
	\begin{subfigure}{0.6\textwidth}
		\includegraphics[width=\linewidth]{Figure/add_nodes1.eps}
		\caption{Old route}
	\end{subfigure}
	\hspace*{0.0cm} % separation between the subfigures
	\begin{subfigure}{0.6\textwidth}
		\includegraphics[width=\linewidth]{Figure/add_nodes2.eps}
		\caption{New route}
	\end{subfigure}
	\caption{Operation of $AddNodes$ (Algorithm~\ref{alg:add_nodes})} \label{fig:add_nodes}
\end{figure}

\begin{figure} [!htbp]
	\centering
	\begin{subfigure}{0.5\textwidth}
		\includegraphics[width=\linewidth]{Figure/tel1.eps}
		\caption{Old route}
	\end{subfigure}
	\hspace*{0.0cm} % separation between the subfigures
	\begin{subfigure}{0.5\textwidth}
		\includegraphics[width=\linewidth]{Figure/tel2.eps}
		\caption{New route}
	\end{subfigure}
	\caption{Operation of $ShortenRoutes$ (Algorithm~\ref{alg:shorten_routes})} \label{fig:shorten_routes}
\end{figure}

\begin{algorithm}[!htbp]
	\caption{$ AddNodes(Routeset, max ) $}
	\textbf{Input:} $Routeset$ (the solution to mutate), $max$\\
	\textbf{Output:} $RouteSet$ (the mutated solution)
	\begin{algorithmic}[1]\label{alg:add_nodes}
		\STATE{ $N_R \gets $ number of routes in $Routeset$}
		\STATE{$I \leftarrow$ select a random integer uniformly from $[1, N_R \times max/2]$} \COMMENT{number of nodes to be added}
		\REPEAT
		\STATE{Choose a route at random without replacement from $Routeset$ }
		\IF{length of this route $ < max $}
		\STATE{If possible add adjacent nodes to either end}
		\STATE{ $I \gets I - $ number of recently added nodes}
		\ENDIF
		\UNTIL{$I = 0$ \OR ($I > 0$ \AND possibilities exhausted) }
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htbp]
	\caption{$ DeleteNodes(Routeset, min ) $}
	\textbf{Input:} $Routeset$, $min$\\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:delete_nodes}
		\STATE{ $N_R \gets $ number of routes in $Routeset$}
		\STATE{$I \leftarrow$ select a random integer uniformly from $[1, N_R \times max/2]$} \COMMENT{number of nodes to be deleted}
		\REPEAT
		\STATE{Choose a route at random without replacement from $Routeset$ }
		\IF{length of this route $ > min $}
		\STATE{If possible delete nodes from either end}
		\STATE{ $I \gets I - $ number of recently deleted nodes}
		\ENDIF
		\UNTIL{$I = 0$ \OR ($I > 0$ \AND possibilities exhausted) }
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[!htbp]
	\caption{$ ShortenRoutes(Routeset, min) $}
	\textbf{Input:} $RouteSet$, $min$\\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:shorten_routes}
		\STATE{ $N_R \gets $ number of routes in $Routeset$}
		\STATE{$I \leftarrow$ select a random integer uniformly from $[1, N_R \times max/2]$} \COMMENT{number of nodes to be deleted}
		\REPEAT
			\STATE{$Route \gets $ choose a route at random without replacement from $Routeset$ }
			\STATE{$p \gets $ select an integer at random from $[0,1]$} \\\COMMENT{randomly choose the traversal direction}
			\IF{$p = 0$}
				\STATE{$k \gets 1$} \COMMENT{traverse the node list from head to tail}
				\WHILE{$k < (N_R-2)$ \AND $I>0$}
					\STATE{$a,b,c \gets $ nodes from $Route$ at positions $k, (k+1), (k+2)$ respectively}
					\IF{length of $ route > min$ \AND $(a,c) \in E$}
						\IF{$t_{ac}<(t_{ab}+t_{bc})$}
							\STATE{If possible delete $(k+1)^{th}$ node from $Route$ \AND decrement $I$}
							%\STATE{$I \gets I - 1$}
						\ENDIF
					\ENDIF
					\STATE{$k \gets k+1$}
				\ENDWHILE
			\ELSE
				\STATE{$k \gets (N_R-3)$} \COMMENT{traverse the node list from tail to head}
				\WHILE{$k>-1$ \AND $I>0$}
					\STATE{$a,b,c \gets $ nodes from $Route$ at positions $k, (k+1), (k+2)$ respectively}
					\IF{length of $ route > min$ \AND $(a,c) \in E$}
						\IF{$t_{ac}<(t_{ab}+t_{bc})$}
							\STATE{If possible delete $(k+1)^{th}$ node from $Route$ \AND decrement $I$}
							%\STATE{ $I \gets I - 1$}
						\ENDIF
					\ENDIF
					\STATE{$k \gets k-1$}
				\ENDWHILE
			\ENDIF
		\UNTIL{$I = 0$ \OR ($I > 0$ \AND possibilities exhausted) }
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htbp]
	\caption{$ ReduceOverlap(Routeset, min) $}
	\textbf{Input:} $RouteSet$, $min$\\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:reduce_overlap}
		\STATE{ $N_R \gets $ number of routes in $Routeset$}
		\STATE{ $U_{ij} \gets $ a matrix that counts the number of edge usage in $Routeset$ for each $ (i,j)\in E $ }
		\STATE{$I \leftarrow$ select a random integer uniformly from $[1, N_R \times max/2]$} \COMMENT{number of nodes to be deleted}
		\REPEAT
		\STATE{$Route \gets $ choose a route at random without replacement from $Routeset$ }
		\STATE{$p \gets $ select an integer at random from $[0,1]$} \\\COMMENT{randomly choose the traversal direction}
		\IF{$p = 0$}
		\STATE{$k \gets 1$} \COMMENT{traverse the node list from head to tail}
		\WHILE{$k < (N_R-2)$ \AND $I>0$}
		\STATE{$a,b,c \gets $ nodes from $Route$ at positions $k, (k+1), (k+2)$ respectively}
		\IF{length of $ route > min$ \AND $(a,c) \in E$}
		\IF{$t_{ac}\times(U_{ac}+1) <(t_{ab}\times(U_{ab}-1)+t_{bc}\times(U_{bc}-1))$}
		\STATE{If possible delete $(k+1)^{th}$ node from $Route$ , increment $U_{ac}$ \AND decrement $I, U_{ab}, U_{bc}$}
		%\STATE{$I \gets I - 1$}
		\ENDIF
		\ENDIF
		\STATE{$k \gets k+1$}
		\ENDWHILE
		\ELSE
		\STATE{$k \gets (N_R-3)$} \COMMENT{traverse the node list from tail to head}
		\WHILE{$k>-1$ \AND $I>0$}
		\STATE{$a,b,c \gets $ nodes from $Route$ at positions $k, (k+1), (k+2)$ respectively}
		\IF{length of $ route > min$ \AND $(a,c) \in E$}
		\IF{$t_{ac}\times(U_{ac}+1) <(t_{ab}\times(U_{ab}-1)+t_{bc}\times(U_{bc}-1))$}
		\STATE{If possible delete $(k+1)^{th}$ node from $Route$ , increment $U_{ac}$ \AND decrement $I, U_{ab}, U_{bc}$}
		%\STATE{ $I \gets I - 1$}
		\ENDIF
		\ENDIF
		\STATE{$k \gets k-1$}
		\ENDWHILE
		\ENDIF
		\UNTIL{$I = 0$ \OR ($I > 0$ \AND possibilities exhausted) }
	\end{algorithmic}
\end{algorithm}
\subsection{Mutation Scheme}
Combining our mutation operators we design five mutation schemes to be used with the MaOEAs named Basic Scheme, Random Scheme I, Random Scheme II, Random Scheme III and Guided Scheme.

Basic Scheme is the simplest mutation scheme. It just picks one operator between $AddNodes$ and $DeleteNodes$ with equal probability and applies it on the solution to mutate. The procedure is presented in Algorithm~\ref{alg:basic_scheme}. The use of such scheme is common in the literature. Motivation behind using Basic Scheme is that any type of route can be achieved by adding and deleting nodes at the end in a random and successive manner. We design subsequent mutation schemes by extending Basic Scheme.

Random Scheme I is a simple modification of Basic Scheme. It picks one operator among $AddNodes$, $DeleteNodes$ and $ShortenRoutes$ with equal probability. The procedure is presented in Algorithm~\ref{alg:random_schemei}. Random Scheme I tries to enhance Basic Scheme by increasing the possibility of generating routes that are shorter in length.

Random Scheme II works in a similar way as Random Scheme I. However it takes slightly more information into account. Algorithmically It picks one operator among $AddNodes$, $DeleteNodes$ and $ReduceOverlap$ with equal probability. The procedure is presented in Algorithm~\ref{alg:random_schemeii}. Random Scheme II aims to enhance Basic Scheme by increasing the possibility of generating shorter routes while minimizing the degree of overlap among different routes of the solution.

Random Scheme III picks one operator among all the mutation operators ($AddNodes$, $DeleteNodes$, $ShortenRoutes$ and $ReduceOverlap$) with equal probability. The procedure is presented in Algorithm~\ref{alg:random_schemeiii}. By applying Random Scheme III we intend to explore whether it is possible to generate good solutions by randomly employing different types of mutations from a large pool of operators.

Unlike other schemes, the Guided Scheme chooses a mutation operator based on the current state of the solution to mutate. At first, it probabilistically selects an objective function that need to be improved for the chosen solution. It accomplishes this by using the normalized objective values of the previous generation. It treats these normalized values as the probabilities of selecting corresponding objective functions. As in this study all the objective functions are to be minimized, the objective whose normalized value is relatively higher should be given more consideration at any time.  Guided Scheme exactly does this. After selecting an objective function, it picks one mutation operator based on fixed preference. For each objective function it maintains a preference list of mutation operators that can improve the objective. The complete procedure can be found in Algorithm~\ref{alg:guided_scheme}.


\begin{algorithm}[!htbp]
	\caption{Basic Scheme}
	\textbf{Input:} $Routeset$ (the solution to mutate)\\
	\textbf{Output:} $RouteSet$ (the mutated solution)
	\begin{algorithmic}[1]\label{alg:basic_scheme}
		\STATE{ $SelectedMutaion \gets $ randomly select an operator among $\{AddNodes, DeleteNodes\}$}\\
		\COMMENT{ Algorithms~\ref{alg:add_nodes}, \ref{alg:delete_nodes}}
		\STATE{$RouteSet \gets SelectedMutaion(RouteSet)$}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[!htbp]
	\caption{Random Scheme I}
	\textbf{Input:} $Routeset$ \\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:random_schemei}
		\STATE{ $SelectedMutaion \gets $ randomly select an operator among \\$\{AddNodes, DeleteNodes, ShortenRoutes\}$} \COMMENT{ Algorithms~\ref{alg:add_nodes}, \ref{alg:delete_nodes}, \ref{alg:shorten_routes} }
		\STATE{$RouteSet \gets SelectedMutaion(RouteSet)$}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[!htbp]
	\caption{Random Scheme II}
	\textbf{Input:} $Routeset$ \\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:random_schemeii}
		\STATE{ $SelectedMutaion \gets $ randomly select an operator among \\$\{AddNodes, DeleteNodes, ReduceOverlap\}$} \COMMENT{ Algorithms~\ref{alg:add_nodes}, \ref{alg:delete_nodes}, \ref{alg:reduce_overlap}}
		\STATE{$RouteSet \gets SelectedMutaion(RouteSet)$}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[!htbp]
	\caption{Random Scheme III}
	\textbf{Input:} $Routeset$ \\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:random_schemeiii}
		\STATE{ $SelectedMutaion \gets $ randomly select an operator among \\$\{AddNodes, DeleteNodes, ShortenRoutes, ReduceOverlap\}$} \COMMENT{ Algorithms~\ref{alg:add_nodes}, \ref{alg:delete_nodes}, \ref{alg:shorten_routes}, \ref{alg:reduce_overlap}}
		\STATE{$RouteSet \gets SelectedMutaion(RouteSet)$}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[!htbp]
	\caption{Guided Scheme}
	\textbf{Input:} $Routeset$\\
	\textbf{Output:} $RouteSet$
	\begin{algorithmic}[1]\label{alg:guided_scheme}
		\STATE{ $SelectedObj \gets $ probabilistically select an objective function based on its normalized value of the previous generation}
		\IF{$SelectedObj$ = minimize in-vehicle travel time}
			\STATE{ $SelectedMutaion \gets ShortenRoutes$}
		\ELSIF{$SelectedObj$ = minimize waiting time}
			\STATE{ $SelectedMutaion \gets $ randomly select an operator from $\{AddNodes, DeleteNodes\}$}
		\ELSIF{$SelectedObj$ = minimize transfer}
			\STATE{ $SelectedMutaion \gets AddNodes$}
		\ELSIF{$SelectedObj$ = minimize fleet size}
			\STATE{ $SelectedMutaion \gets$ randomly select an operator from $\{AddNodes, DeleteNodes\}$}
		\ELSIF{$SelectedObj$ = minimize route length}
			\STATE{$SelectedMutaion \leftarrow$ randomly select an operator from $\{DeleteNodes, ShortenRoutes\}$}
		\ELSIF{$SelectedObj$ = minimize unsatisfied demand}
			\STATE{ $SelectedMutaion \gets AddNodes$}
		\ELSE
			\STATE{ $SelectedMutaion \gets$ randomly select an operator from $\{DeleteNodes, ReduceOverlap\}$}
		\ENDIF
		\STATE{$RouteSet \gets SelectedMutaion(RouteSet)$}
	\end{algorithmic}
\end{algorithm}

\subsection{Many-Objective Evolutionary Algorithm}

We adapted four state-of-the-art algorithms to solve TNDP using our solution initialization procedure, crossover operator and mutation schemes described so far. The selected algorithms are SPEA2, MOEA/D, NSGAIII and $\theta$-DEA. Among them SPEA2 is classified as MOEA and the rest ones are classified as MaOEA in the literature.

SPEA2 was proposed by Zitzler \textit{et al.}~\cite{zitzler2001spea2} as an improved elitist MOEA that employs an enhanced fitness assignment strategy to rank solutions compared to its predecessor SPEA as well as new technique for archive truncation. It is well-known for good performance. It uses an external set (archive) in addition to the usual population for storing primarily non-dominated solutions. It is then combined with the current population to form the next archive which is used to create offspring for the next generation. If the size of new archive exceeds a predefined limit, SPEA2 applies the archive truncation technique to remove solutions from archive.
%As the concept Pareto dominance fails to rank solutions properly when most solutions do not dominate each other, SPEA2 incorporate k-nearest neighbor based density information to rank solutions.
The procedure of SPEA2 for TNDP is presented in Algorithm~\ref{alg:spea2}.

\begin{algorithm}[!htbp]
	\caption{SPEA2 for TNDP}
	\textbf{Input:} $T$ (maximum number of generations), $N$ (population size), $\overline{N}$ (archive size), $C_r$ (crossover rate), $MutScheme$ (chosen mutation scheme)\\
	\textbf{Output:} $P^*$ (non-dominated solutions)
	\begin{algorithmic}[1]\label{alg:spea2}
		\STATE{$P_0 \gets$ initialize population with $N$ randomly generated solutions using Algorithm~\ref{alg:init_procedure}}
		\STATE{Evaluate the objective functions of each individual in $ P_0 $}
		\STATE{$\overline{P_0} \gets \emptyset$} \COMMENT{external archive}
		\STATE{$t \gets 0$}
		\WHILE{$ t < T$}
		\STATE{$ R_t \gets P_t \cup \overline{P}_t $}
		\STATE{Calculate SPEA2 fitness value for each solution in $ R_t $}
		\STATE{$\overline{P}_{t+1} \gets$ create new archive of size $\overline{N}$ using the non-dominated solutions in $R_t$ }
		\STATE{$P_{t+1} \gets$ create new population of size $N$ by applying crossover and \\$MutScheme$ on $\overline{P}_{t+1}$}
		\STATE{Evaluate the objective functions of each solution in $ P_{t+1} $}
		\STATE{$ t \gets t+1 $}
		\ENDWHILE
		\STATE{$P^* \gets$ extract non-dominated solutions from $\overline{P}_t$}
	\end{algorithmic}
\end{algorithm}

MOEA/D, proposed by Zhang and Li~\cite{zhang2007moea}, is one of the most well-known decomposition based MaOEA. It decomposes a MaOP into many single-objective subproblems by employing an aggregation function that combines all objectives and a series of weight vectors that define the relative importance of different objectives. We use the Das and Dennis's procedure~\cite{das1998normal} for generating uniform weight vectors, which are evenly distributed along the 7-dimensional unit hyper-plane. Then it deals with these subproblems in a collaborative manner. Neighborhood relations among these subproblems are defined based on the similarity between their weight vectors. When optimizing a subproblem, the local information from its neighboring subproblems is shared. In MOEA/D, each subproblem maintains one individual in its memory, which could be the best individual found so far for it. For each subproblem, the algorithm generates a new individual by performing genetic operators on some of its neighboring individuals (i.e., the individuals of its neighboring subproblems). The memory of both the considered subproblem and its neighboring subproblems will be updated if the new individual is better than their current one. The procedure of MOEA/D for TNDP is presented in Algorithm~\ref{alg:moead}.

\begin{algorithm}[!htbp]
	\caption{MOEA/D for TNDP}
	\textbf{Input:} $T$ (maximum number of generations), $N$ (population size), $T'$ (number of the weight vectors in the neighborhood of each weight vector), $\delta$ (probability that mating solution is selected from the neighborhood),  $C_r$ (crossover rate), $MutScheme$ (chosen mutation scheme)\\ %$n_r$ (maximal number of solutions replaced by each child solution),
	\textbf{Output:} $P^*$ (non-dominated solutions)
	\begin{algorithmic}[1]\label{alg:moead}
		\STATE{$P_0 \gets$ initialize population with $N$ randomly generated solutions using Algorithm~\ref{alg:init_procedure}}
		\STATE{Evaluate the objective functions of each solution in $ P_0 $}
		\STATE{$\lambda \gets$ generate $N$ uniform weight vectors}
		\STATE{Compute the Euclidean distances between any two weight vectors and then work out the $T'$ closest weight vectors to each weight vector}
		\STATE{$z^* \gets$ initialize ideal point for the Tchebycheff approach}
		\STATE{$t \gets 0$}
		\WHILE{$ t < T$}
		\STATE{Permute the solutions in $P_t$}
		\FOR{$i = 1$ to $N$}
		\STATE{$Parents \gets$ an array of 2 solutions}
		\STATE{$Parents[0] \gets i^{th}$ solution in $P_t$ }
		\STATE{$p \gets $ select an integer at random from $[0,1]$}
		\IF{$p < \delta$}
		\STATE{$Parents[1] \gets $ randomly select a solution from the neighborhood of $Parents[0]$ }
		\ELSE
		\STATE{$Parents[1] \gets $ randomly select a solution from the whole population }
		\ENDIF
		\STATE{$Child \gets$ generate an offspring by applying crossover and $MutScheme$ on $Parents$}
		\STATE{Evaluate the objective functions of $Child$}
		\STATE{Update $z^*$ based on $Child$}
		\STATE{Update of neighboring solutions based on $Child$}
		\ENDFOR
		\STATE{$ t \gets t+1 $}
		\ENDWHILE
		\STATE{$P^* \gets$ extract non-dominated solutions from $P_t$}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htbp]
	\caption{NSGAIII for TNDP}
	\textbf{Input:} $T$ (maximum number of generations), $N$ (population size), $C_r$ (crossover rate), $MutScheme$ (chosen mutation scheme)\\
	\textbf{Output:} $P^*$ (non-dominated solutions)
	\begin{algorithmic}[1]\label{alg:nsgaiii}
		\STATE{$P_0 \gets$ initialize population with $N$ randomly generated solutions using Algorithm~\ref{alg:init_procedure}}
		\STATE{Evaluate the objective functions of each individual in $ P_0 $}
		\STATE{$Z^r \gets$ generate $N$ uniform reference points}
		\STATE{$t \gets 0$}
		\WHILE{$ t < T$}
		\STATE{$Q_t \gets$ create offspring population of size $N$ by applying crossover and \\$MutScheme$ on $P_t$}
		\STATE{Evaluate the objective functions of each solution in $ Q_t $}
		\STATE{$ R_t \gets P_t \cup Q_t $}
		\STATE{$(F_1,F_2,\dots) \gets$ classify $R_t$ into different pareto non-domination levels }
		\STATE{Fill $S_t$ using one pareto non-domination level at a time starting from $F_1$ \\such that $|S_t| \ge N$}
		\STATE{$F_l \gets$ last front to be included}
		\IF{$ |S_t| = N $}
		\STATE{$P_{t+1} = S_t$}
		\STATE{\textbf{continue}}
		\ELSE
		\STATE{$P_{t+1} = \cup_{j=1}^{l-1} F_j$}
		\STATE{$K = N - |P_{t+1}|$} \COMMENT{number of solutions to be chosen from $F_l$}
		\STATE{Normalize objectives of $S_t$}
		\STATE{Associate each member $s$ of $S_t$ with a reference point in $Z^r$}
		\STATE{Compute niche count of each reference point $j \in Z^r$}
		\STATE{Choose $K$ solutions one at a time from $F_l$ to construct $P_{t+1}$}
		\ENDIF
		\STATE{$ t \gets t+1 $}
		\ENDWHILE
		\STATE{$P^* \gets$ extract non-dominated solutions from $P_t$}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htbp]
	\caption{$\theta$-DEA for TNDP}
	\textbf{Input:} $T$ (maximum number of generations), $N$ (population size), $C_r$ (crossover rate), $MutScheme$ (chosen mutation scheme)\\
	\textbf{Output:} $P^*$ (non-dominated solutions)
	\begin{algorithmic}[1]\label{alg:theta_dea}
		\STATE{$P_0 \gets$ initialize population with $N$ randomly generated solutions using Algorithm~\ref{alg:init_procedure}}
		\STATE{Evaluate the objective functions of each solution in $ P_0 $}
		\STATE{$Z^r \gets$ generate $N$ uniform reference points}
		\STATE{$z^* \gets$ initialize ideal point}
		\STATE{$z^{nad} \gets$ initialize nadir point}
		\STATE{$t \gets 0$}
		\WHILE{$ t < T$}
		\STATE{$Q_t \gets$ create offspring population of size $N$ by applying crossover and \\$MutScheme$ on $P_t$}
		\STATE{Evaluate the objective functions of each solution in $ Q_t $}
		\STATE{$ R_t \gets P_t \cup Q_t $}
		\STATE{$ S_t \gets$ get pareto non-dominated fronts from $R_t$}
		\STATE{Update ideal point using $S_t$}
		\STATE{Normalize objectives of $S_t$ using $z^*$ and $z^{nad}$}
		\STATE{$C \gets$ split the solutions in $S_t$ into a set of $N$ clusters using $Z^r$}
		\STATE{$(F_1',F_2',\dots) \gets$ classify $S_t$ into different $\theta$-non-domination levels }
		\STATE{$P_{t+1} \gets \emptyset$}
		\STATE{Fill $N$ slots of $P_{t+1}$ using one $\theta$-non-domination level at a time starting from $F_1'$}
		\IF{last accpeted level will be used partially to fill $N$ slots}
		\STATE{Add randomly selected solutions from the last level to $P_{t+1}$}
		\ENDIF
		\STATE{$ t \gets t+1 $}
		\ENDWHILE
		\STATE{$P^* \gets$ extract non-dominated solutions from $P_t$}
	\end{algorithmic}
\end{algorithm}

Deb and Jain proposed NSGAIII~\cite{deb2014evolutionary}. It is a representative of reference-point based MaOEAs. The basic framework of NSGAIII remains similar to its predecessor NSGAII~\cite{deb2002fast} with significant changes in its selection mechanism. NSGAIII starts with a randomly generated initial population. Then it generates required number of uniform reference points using Das and Dennis's procedure~\cite{das1998normal}.  At each generation, the current population is used to produce an offspring population by applying crossover operator and mutation scheme. These two populations are merged together to form a new population using the selection mechanism. NSGAIII continues to use Pareto dominance as the primary selection criterion to promote convergence. But it replaces the crowding distance operator in NSGAII with a clustering operator aided by a set of well-distributed reference points as the secondary selection criterion to maintain diversity. It employs the secondary criterion if the primary criterion fails to select the required number of evolved solutions. Since poorly converged solutions are often far away from the reference lines (i.e., the lines connecting the reference points with the ideal point), the clustering operator implicitly prefers solutions with good convergence, thus leading to the algorithm better than traditional Pareto-based algorithms in a high-dimensional space. NSGAIII has been shown to be promising on various MaOPs~\cite{deb2014evolutionary}, including those with an irregular or a discontinuous PF on which the decomposition-based approach typically encounters difficulty. The procedure of NSGAIII for TNDP is presented in Algorithm~\ref{alg:nsgaiii}.

$\theta$-DEA has been recently proposed by Yuan \textit{et al.}~\cite{yuan2016new} as a new dominance relation based MaOEA. This algorithm is motivated by the strength and weakness of NSGAIII and MOEA/D. NSGAIII prefers population members that are Pareto non-dominated but are close to the reference lines. Nevertheless, with large number of objectives the Pareto-dominance relation fails to impose enough selection pressure to push the population towards PF. Therefore NSGAIII stresses diversity more than convergence in such cases. On the other hand, MOEA/D implicitly maintains the diversity via the diverse weight vectors, and it could generally approach the PF very well by means of the aggregation function based selection operator. However, MOEA/D determines whether a new solution replaces an old solution or not is solely by their aggregation function values. Such replacement may lead to severe loss of diversity in many-objective optimization. The major reason is that, in high-dimensional objective space, it is highly possible that a solution achieves a good aggregation function value but is far away from the corresponding weight vector. Thus, MOEA/D is at high risk of missing some search regions if aggregation function values are emphasized too much. This issue has been experimentally observed in several recent studies on many-objective optimization~\cite{ deb2014evolutionary, li2013comparative}. While designing $\theta$-DEA, the proponents aimed to enhance the convergence of NSGAIII in many-objective optimization by exploiting the fitness evaluation scheme in MOEA/D, still inheriting the strength of NSGAIII in preserving the diversity. To accomplish this they introduced a new dominance relation named as $\theta$-dominance. In $\theta$-dominance, solutions are allocated into different clusters represented by well-distributed reference points. Only the solutions within the same cluster have the competitive relationship.  $\theta$-DEA works in a similar way as NSGAIII. But when it selects solutions for the next generation, the non-dominated sorting scheme~\cite{golberg1989genetic} based on $\theta$-dominance not only prefers solutions with better fitness values in each cluster, but also ensures that the selected solutions distribute as evenly as possible between these clusters. $\theta$-DEA has been demonstrated to be a promising alternative for many-objective optimization~\cite{yuan2016new} through an extensive comparison with eight state-of-the-art algorithms. The procedure of $\theta$-DEA for TNDP is presented in Algorithm~\ref{alg:theta_dea}.

\section{Difference with Recent Work}
In this section, we look at how the MaOEA based framework is different from recent research studies. The differences are discussed as follows:

\begin{itemize}
\item Recent works on TNDP that optimized multiple objective functions, applied MOEAs like NSGAII, SPEA2. However, these MOEAs struggle to achieve convergence and diversity when dealing with MaOPs. In this study we apply recently proposed MaOEAs like NSGAIII, $\theta$-DEA to solve TNDP for the first time. These algorithms are designed to address challenges posed by MaOPs.

\item Most of the recent works combined three different types of passenger cost: in-vehicle travel time, waiting time and transfer percentage into a single objective function named \textit{Average Travel Time (ATT)}. But there is trade-off relationship among them which will be evident in the next chapter. As a result, it is not possible to fully explore the trade-off surface. In this study we treat each of those passenger costs as an independent objective function.

\item Most literature that used mutation operator to randomly modify a solution, did not consider the current state of the solution. However in this study we design a new Guided Scheme for mutation which selects the type of modification in a way to improve those objective values that are relatively worse at a particular moment.

\item To avoid dealing with many objective functions, some works turn several objectives into problem constraints and set bounds of acceptable values. Any change in those values would require them to rerun their algorithms. But that does not occur in our case. We generate a set of trade-off solutions considering all the objective functions explicitly. While decision making, a transport planner can impose any criteria as constraint by just filtering the obtained solutions based on that criteria.

\item Unlike previous works, in this study we introduce degree of route overlap as a minimization objective from the viewpoint of local authority. This is an indicator of traffic congestion caused by sharing road segments by multiple bus routes.
\end{itemize}

\section{Summary}
In this chapter, we described our proposed methodology. We formulated the objective functions and trip assignment model required to evaluate a solution of TNDP. Afterwards we presented the main components of our MaOEA based framework such as solution encoding, initialization technique, crossover and mutation scheme. Next we briefly introduced several state-of-the-art MaOEAs that we adapted for solving TNDP. We ended with a discussion of differences between our approach and other recent works.
